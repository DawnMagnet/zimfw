# This runs in a new shell
builtin emulate -L zsh
integer PRINTLEVEL=${1}
readonly -i SUBMODULES=${8}
readonly ACTION=${2} MODULE=${3} DIR=${4} URL=${5} TYPE=${6} ONPULL=${9}
REV=${7}

print_error() {
  print -u2 -PlR <%= clear_line %>"%F{red}<%= error %>%B${MODULE}:%b ${1}%f" ${2:+${(F):-  ${(f)^2}}}
}

print_okay() {
  if (( PRINTLEVEL > 0 )) print -PlR <%= clear_line %>"<%= okay %>%B${MODULE}:%b ${1}" ${2:+${(F):-  ${(f)^2}}}
}

on_pull() {
  if [[ -n ${ONPULL} ]]; then
    if ! ERR=$(builtin cd -q ${DIR} 2>&1 && builtin eval ${ONPULL} 2>&1); then
      print_error 'Error during on-pull' ${ERR}
      return 1
    elif [[ ${PRINTLEVEL} -gt 1 && -n ${ERR} ]]; then
      builtin set ${1} ${2:+${2}$'\n'}'On-pull output:'$'\n'${ERR}
    fi
  fi
}

case ${ACTION} in
  install)
    if ERR=$(command git clone ${REV:+-b} ${REV} -q --config core.autocrlf=false ${${SUBMODULES:#0}:+--recursive} -- ${URL} ${DIR} 2>&1); then
      on_pull && print_okay Installed
    else
      print_error 'Error during git clone' ${ERR}
      return 1
    fi
    ;;
  check|update)
    if [[ ! -r ${DIR}/.git ]]; then
      if (( PRINTLEVEL > 0 )); then
        print -u2 -PR <%= clear_line %>"%F{yellow}<%= warn %>%B${MODULE}:%b Module was not installed using git. Will not try to ${ACTION}. Use zmodule option %B-z%b|%B--frozen%b to disable this warning.%f"
      fi
      return 0
    fi
    if [[ ${URL} != $(command git -C ${DIR} config --get remote.origin.url) ]]; then
      print_error "URL does not match. Expected ${URL}. Will not try to ${ACTION}."
      return 1
    fi
    if ! ERR=$(command git -C ${DIR} fetch -pqt origin 2>&1); then
      print_error 'Error during git fetch' ${ERR}
      return 1
    fi
    if [[ ${TYPE} == branch ]]; then
      if [[ -z ${REV} ]]; then
        # Get HEAD remote branch
        if ! ERR=$(command git -C ${DIR} remote set-head origin -a 2>&1); then
          print_error 'Error during git remote set-head' ${ERR}
          return 1
        fi
        if REV=$(command git -C ${DIR} symbolic-ref --short refs/remotes/origin/HEAD 2>&1); then
          REV=${REV#origin/}
        else
          print_error 'Error during git symbolic-ref' ${REV}
          return 1
        fi
      fi
      TO_REV=${REV}@{u}
      if [[ ${ACTION} == check ]]; then
        local -ri behind=$(command git -C ${DIR} rev-list --count ${REV}..${TO_REV} -- 2>/dev/null)
        if (( behind )); then
          print_okay "Update available [behind ${behind}]"
        else
          (( PRINTLEVEL-- ))
          print_okay 'Already up to date'
        fi
        return 0
      fi
    else
      if [[ ${REV} == $(command git -C ${DIR} describe --tags --exact-match 2>/dev/null) ]]; then
        if [[ ${ACTION} == check ]]; then
          (( PRINTLEVEL-- ))
          print_okay 'Already up to date'
          return 0
        else
          on_pull && print_okay 'Already up to date'
          return ${?}
        fi
      fi
      if [[ ${ACTION} == check ]]; then
        print_okay 'Update available'
        return 0
      fi
      TO_REV=${REV}
    fi
    LOG=$(command git -C ${DIR} log --graph --color --format='%C(yellow)%h%C(reset) %s %C(cyan)(%cr)%C(reset)' ..${TO_REV} -- 2>/dev/null)
    if ! ERR=$(command git -C ${DIR} checkout -q ${REV} -- 2>&1); then
      print_error 'Error during git checkout' ${ERR}
      return 1
    fi
    if [[ ${TYPE} == branch ]]; then
      if ! OUT=$(command git -C ${DIR} merge --ff-only --no-progress -n 2>&1); then
        print_error 'Error during git merge' ${OUT}
        return 1
      fi
      # keep just first line of OUT
      OUT=${OUT%%($'\n'|$'\r')*}
    else
      OUT="Updating to ${TYPE} ${REV}"
    fi
    if (( SUBMODULES )); then
      if ! ERR=$(command git -C ${DIR} submodule update --init --recursive -q -- 2>&1); then
        print_error 'Error during git submodule update' ${ERR}
        return 1
      fi
    fi
    on_pull && print_okay ${OUT} ${LOG}
    ;;
esac
