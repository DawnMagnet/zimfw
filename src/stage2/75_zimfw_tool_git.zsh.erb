_zimfw_tool_git() {
  local -ri zsubmodules=${5}
  local -r zdir=${1} zurl=${2} ztype=${3} zonpull=${6}
  local zrev=${4} ztorev zerr zout zlog
  case ${_zaction} in
    install)
      if zerr=$(command git clone ${zrev:+-b} ${zrev} -q --config core.autocrlf=false ${${zsubmodules:#0}:+--recursive} -- ${zurl} ${zdir} 2>&1); then
        _zimfw_pull_print_okay Installed
      else
        _zimfw_print_error 'Error during git clone' ${zerr}
        return 1
      fi
      ;;
    check|update)
      if [[ ! -r ${zdir}/.git ]]; then
        if (( _zprintlevel > 0 )); then
          print -u2 -PR <%= clear_line %>"%F{yellow}<%= warn %>%B${_zname}:%b Module was not installed using git. Will not try to ${_zaction}. Use zmodule option %B-z%b|%B--frozen%b to disable this warning.%f"
        fi
        return 0
      fi
      if [[ ${zurl} != $(command git -C ${zdir} config --get remote.origin.url) ]]; then
        _zimfw_print_error "zurl does not match. Expected ${zurl}. Will not try to ${_zaction}."
        return 1
      fi
      if ! zerr=$(command git -C ${zdir} fetch -pqt origin 2>&1); then
        _zimfw_print_error 'Error during git fetch' ${zerr}
        return 1
      fi
      if [[ ${ztype} == branch ]]; then
        if [[ -z ${zrev} ]]; then
          # Get HEAD remote branch
          if ! zerr=$(command git -C ${zdir} remote set-head origin -a 2>&1); then
            _zimfw_print_error 'Error during git remote set-head' ${zerr}
            return 1
          fi
          if zrev=$(command git -C ${zdir} symbolic-ref --short refs/remotes/origin/HEAD 2>&1); then
            zrev=${zrev#origin/}
          else
            _zimfw_print_error 'Error during git symbolic-ref' ${zrev}
            return 1
          fi
        fi
        ztorev=${zrev}@{u}
        if [[ ${_zaction} == check ]]; then
          local -ri behind=$(command git -C ${zdir} rev-list --count ${zrev}..${ztorev} -- 2>/dev/null)
          if (( behind )); then
            _zimfw_print_okay "Update available [behind ${behind}]"
            return 4
          else
            _zimfw_print_okay 'Already up to date' 1
            return 0
          fi
        fi
      else
        if [[ ${zrev} == $(command git -C ${zdir} describe --tags --exact-match 2>/dev/null) ]]; then
          if [[ ${_zaction} == check ]]; then
            _zimfw_print_okay 'Already up to date' 1
            return 0
          else
            _zimfw_pull_print_okay 'Already up to date'
            return ${?}
          fi
        fi
        if [[ ${_zaction} == check ]]; then
          _zimfw_print_okay 'Update available'
          return 4
        fi
        ztorev=${zrev}
      fi
      zlog=$(command git -C ${zdir} log --graph --color --format='%C(yellow)%h%C(reset) %s %C(cyan)(%cr)%C(reset)' ..${ztorev} -- 2>/dev/null)
      if ! zerr=$(command git -C ${zdir} checkout -q ${zrev} -- 2>&1); then
        _zimfw_print_error 'Error during git checkout' ${zerr}
        return 1
      fi
      if [[ ${ztype} == branch ]]; then
        if ! zout=$(command git -C ${zdir} merge --ff-only --no-progress -n 2>&1); then
          _zimfw_print_error 'Error during git merge' ${zout}
          return 1
        fi
        # keep just first line of zout
        zout=${zout%%($'\n'|$'\r')*}
      else
        zout="Updating to ${ztype} ${zrev}"
      fi
      if (( zsubmodules )); then
        if ! zerr=$(command git -C ${zdir} submodule update --init --recursive -q -- 2>&1); then
          _zimfw_print_error 'Error during git submodule update' ${zerr}
          return 1
        fi
      fi
      _zimfw_pull_print_okay ${zout} 0 ${zlog}
      ;;
  esac
}
